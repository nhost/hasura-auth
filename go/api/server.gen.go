// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version (devel) DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Sign in with email and password
	// (POST /signin/email-password)
	PostSigninEmailPassword(c *gin.Context)
	// Sign in with magic link sent to user's email. If user doesn't exist, it will be created. The options object is optional and can be used to set the user's when signing up a new user. It is ignored if the user already exists.
	// (POST /signin/passwordless/email)
	PostSigninPasswordlessEmail(c *gin.Context)
	// Signup with email and password
	// (POST /signup/email-password)
	PostSignupEmailPassword(c *gin.Context)
	// Change user email
	// (POST /user/email/change)
	PostUserEmailChange(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// PostSigninEmailPassword operation middleware
func (siw *ServerInterfaceWrapper) PostSigninEmailPassword(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSigninEmailPassword(c)
}

// PostSigninPasswordlessEmail operation middleware
func (siw *ServerInterfaceWrapper) PostSigninPasswordlessEmail(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSigninPasswordlessEmail(c)
}

// PostSignupEmailPassword operation middleware
func (siw *ServerInterfaceWrapper) PostSignupEmailPassword(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSignupEmailPassword(c)
}

// PostUserEmailChange operation middleware
func (siw *ServerInterfaceWrapper) PostUserEmailChange(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostUserEmailChange(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/signin/email-password", wrapper.PostSigninEmailPassword)
	router.POST(options.BaseURL+"/signin/passwordless/email", wrapper.PostSigninPasswordlessEmail)
	router.POST(options.BaseURL+"/signup/email-password", wrapper.PostSignupEmailPassword)
	router.POST(options.BaseURL+"/user/email/change", wrapper.PostUserEmailChange)
}

type PostSigninEmailPasswordRequestObject struct {
	Body *PostSigninEmailPasswordJSONRequestBody
}

type PostSigninEmailPasswordResponseObject interface {
	VisitPostSigninEmailPasswordResponse(w http.ResponseWriter) error
}

type PostSigninEmailPassword200JSONResponse SignInEmailPasswordResponse

func (response PostSigninEmailPassword200JSONResponse) VisitPostSigninEmailPasswordResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSigninPasswordlessEmailRequestObject struct {
	Body *PostSigninPasswordlessEmailJSONRequestBody
}

type PostSigninPasswordlessEmailResponseObject interface {
	VisitPostSigninPasswordlessEmailResponse(w http.ResponseWriter) error
}

type PostSigninPasswordlessEmail200JSONResponse OKResponse

func (response PostSigninPasswordlessEmail200JSONResponse) VisitPostSigninPasswordlessEmailResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSignupEmailPasswordRequestObject struct {
	Body *PostSignupEmailPasswordJSONRequestBody
}

type PostSignupEmailPasswordResponseObject interface {
	VisitPostSignupEmailPasswordResponse(w http.ResponseWriter) error
}

type PostSignupEmailPassword200JSONResponse SessionPayload

func (response PostSignupEmailPassword200JSONResponse) VisitPostSignupEmailPasswordResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSignupEmailPassword403JSONResponse ErrorResponse

func (response PostSignupEmailPassword403JSONResponse) VisitPostSignupEmailPasswordResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PostSignupEmailPassword409JSONResponse ErrorResponse

func (response PostSignupEmailPassword409JSONResponse) VisitPostSignupEmailPasswordResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type PostUserEmailChangeRequestObject struct {
	Body *PostUserEmailChangeJSONRequestBody
}

type PostUserEmailChangeResponseObject interface {
	VisitPostUserEmailChangeResponse(w http.ResponseWriter) error
}

type PostUserEmailChange200JSONResponse OKResponse

func (response PostUserEmailChange200JSONResponse) VisitPostUserEmailChangeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Sign in with email and password
	// (POST /signin/email-password)
	PostSigninEmailPassword(ctx context.Context, request PostSigninEmailPasswordRequestObject) (PostSigninEmailPasswordResponseObject, error)
	// Sign in with magic link sent to user's email. If user doesn't exist, it will be created. The options object is optional and can be used to set the user's when signing up a new user. It is ignored if the user already exists.
	// (POST /signin/passwordless/email)
	PostSigninPasswordlessEmail(ctx context.Context, request PostSigninPasswordlessEmailRequestObject) (PostSigninPasswordlessEmailResponseObject, error)
	// Signup with email and password
	// (POST /signup/email-password)
	PostSignupEmailPassword(ctx context.Context, request PostSignupEmailPasswordRequestObject) (PostSignupEmailPasswordResponseObject, error)
	// Change user email
	// (POST /user/email/change)
	PostUserEmailChange(ctx context.Context, request PostUserEmailChangeRequestObject) (PostUserEmailChangeResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// PostSigninEmailPassword operation middleware
func (sh *strictHandler) PostSigninEmailPassword(ctx *gin.Context) {
	var request PostSigninEmailPasswordRequestObject

	var body PostSigninEmailPasswordJSONRequestBody
	if err := ctx.ShouldBind(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.PostSigninEmailPassword(ctx, request.(PostSigninEmailPasswordRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSigninEmailPassword")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(PostSigninEmailPasswordResponseObject); ok {
		if err := validResponse.VisitPostSigninEmailPasswordResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSigninPasswordlessEmail operation middleware
func (sh *strictHandler) PostSigninPasswordlessEmail(ctx *gin.Context) {
	var request PostSigninPasswordlessEmailRequestObject

	var body PostSigninPasswordlessEmailJSONRequestBody
	if err := ctx.ShouldBind(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.PostSigninPasswordlessEmail(ctx, request.(PostSigninPasswordlessEmailRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSigninPasswordlessEmail")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(PostSigninPasswordlessEmailResponseObject); ok {
		if err := validResponse.VisitPostSigninPasswordlessEmailResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSignupEmailPassword operation middleware
func (sh *strictHandler) PostSignupEmailPassword(ctx *gin.Context) {
	var request PostSignupEmailPasswordRequestObject

	var body PostSignupEmailPasswordJSONRequestBody
	if err := ctx.ShouldBind(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.PostSignupEmailPassword(ctx, request.(PostSignupEmailPasswordRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSignupEmailPassword")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(PostSignupEmailPasswordResponseObject); ok {
		if err := validResponse.VisitPostSignupEmailPasswordResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostUserEmailChange operation middleware
func (sh *strictHandler) PostUserEmailChange(ctx *gin.Context) {
	var request PostUserEmailChangeRequestObject

	var body PostUserEmailChangeJSONRequestBody
	if err := ctx.ShouldBind(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.PostUserEmailChange(ctx, request.(PostUserEmailChangeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostUserEmailChange")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(PostUserEmailChangeResponseObject); ok {
		if err := validResponse.VisitPostUserEmailChangeResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
